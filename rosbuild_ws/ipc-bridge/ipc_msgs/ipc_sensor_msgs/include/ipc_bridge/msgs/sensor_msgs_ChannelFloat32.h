/* automatically generated by xdrgen from xdr/sensor_msgs_ChannelFloat32.xdr
 * xdrgen cvs version: $Revision: 1.7 $ $Date: 2009/01/12 15:54:59 $
 * xdr/sensor_msgs_ChannelFloat32.xdr last modified: Thu Jan 27 15:41:58 2011
 */

#ifndef INCsensor_msgs_ChannelFloat32_h
#define INCsensor_msgs_ChannelFloat32_h



#include <cstring>


struct sensor_msgs_ChannelFloat32 {
  char *name;
  unsigned int values_length;
  float *values;
#define sensor_msgs_ChannelFloat32_IPC_FORMAT "{string,uint,<float:2>}"
  static const char *getIPCFormat(void) {
    return sensor_msgs_ChannelFloat32_IPC_FORMAT;
  }


  sensor_msgs_ChannelFloat32() : name(0), values(0) {}
  sensor_msgs_ChannelFloat32(const sensor_msgs_ChannelFloat32 &msg) :
    values_length(msg.values_length)
  {
    name = new char[strlen(msg.name) + 1];
    strcpy(name, msg.name);

    if (values != 0)
      delete[] values;

    values = 0;
    if (msg.values_length > 0)
      {
        values = new float[values_length];
        memcpy((void*)values, (void*)msg.values, 
               values_length*sizeof(float));
      }
  }
  ~sensor_msgs_ChannelFloat32()
  {
    if (name != 0)
      delete[] name;

    if (values != 0)
      delete[] values;
    values = 0;
  }
  sensor_msgs_ChannelFloat32& operator= (const sensor_msgs_ChannelFloat32& msg)
  {
    if (name != 0)
      delete[] name;

    name = new char[strlen(msg.name) + 1];
    strcpy(name, msg.name);

    values_length = msg.values_length;

    if (values != 0)
      delete[] values;

    values = 0;
    if (msg.values_length > 0)
      {
        values = new float[values_length];
        memcpy((void*)values, (void*)msg.values, 
               values_length*sizeof(float));
      }

    return *this;
  } 

};


namespace ipc_bridge
{
    namespace sensor_msgs
    {
        typedef sensor_msgs_ChannelFloat32 ChannelFloat32;
    }
}


#endif /* INCsensor_msgs_ChannelFloat32_h */
